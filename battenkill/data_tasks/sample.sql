/* Our database contains two tables. One table contains daily records of cash balances for many accounts.
The other table contains records of predicted cash balances for the same accounts.  The predictions were generated by
a forecasting model.  One model is trained on one account's data_tasks, such that we have many models, one for each account.
We've built a forecasting model "factory" and need to monitor how good its models are at predicting cash balances.

About half of the accounts are in some way dormant: their balances are always zero, or the same every day.  Our factory
just returns zero or the constant balance for these accounts, so they are irrelevant to measuring model performance.
*/

with deduplicated as(
    select
        account_id,
        as_of_date,
        balance,
        yhat
    from historical_balances
    where
        balance_code = 'EOD'  -- we only want the end-of-day balance (many other balance types exist)
        and as_of_date between to_date('2023-01-01', 'yyyy-mm-dd')
            and to_date('2025-06-30', 'yyyy-mm-dd')
    group by
        account_id, as_of_date, balance, yhat  -- we only want recent data_tasks
),

zero_labels as(
    select
        account_id,
        as_of_date,
        balance,
        case when balance = 0 then 1 else 0 end as is_zero_label
    from deduplicated
),

active_accounts as(
    select
        account_id
    from zero_labels
    group by account_id
    having sum(is_zero_label)/count(is_zero_label) < 0.05 -- at least 95% of balances are non-zero
        and avg(balance) != max(balance)  -- balance must vary
        -- and stddev(balance)/avg(balance) > 0.2  -- optional: balance must vary enough to be interesting
),

errors_for_metrics as (
    select
        p.account_id,
        p.as_of_date,  -- date model served the predictions
        p.target_date, -- dates for which the model made predictions
        abs(p.balance) as abs_true,
        abs(p.yhat - p.balance) as abs_error,
        -- avoid division by zero
        case
            when p.yhat = 0 and p.balance = 0 then 0
            when p.balance = 0 then NULL
            else abs((p.yhat - p.balance) / p.balance)
        end as ape
    from model_predictions p
        where p.account_id in (select account_id from active_accounts)
),

select
    account_id,
    as_of_date,
    count(target_date) as oot_samples,
    percentile_cont(0.5) within group (order by ape) as median_ape,
    sum(abs_error)/sum(abs_true) as mape
from errors_for_metrics
group by
    account_id, as_of_date
